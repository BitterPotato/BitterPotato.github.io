{"meta":{"title":"Yang Weijie's blog","subtitle":"Welcome and have fun!","description":"这个人懒死了，什么都没有写('・ˍ・ `)","author":"Yang Weijie","url":"http://site.com"},"pages":[],"posts":[{"title":"QuickSort","slug":"QuickSort","date":"2016-12-13T04:05:57.000Z","updated":"2016-12-13T04:18:08.351Z","comments":true,"path":"2016/12/13/QuickSort/","link":"","permalink":"http://site.com/2016/12/13/QuickSort/","excerpt":"","text":"概述快速排序是面试中的常见题，每次简述一遍快速排序的原理便觉得仿佛已经掌握了它。不是挺简单的吗？然而实际实现的时候还是会遇到一些坑。于是，之前一次面试就跪了，很尴尬。所以，还是需要对它进行深入理解！ 基本步骤 检查范围，(以及终止条件) 注意递归终止条件 选择基准(pivot)，分割序列 即筛选不大于pivot的元素和不小于pivot的元素），将pivot放至正确位置 对pivot的左半段和右半段序列分别进行快速排序 参考[1], 我将快速排序的函数签名定为public &lt;T extends Comparable&lt;? super T&gt;&gt; void executeProcess(T[] sequ, int left, int right) { } 1.小数组优化递归的快速排序终会落入对于小数组的排序。而对于小数组的排序，快速排序不如插入排序。 quicksort insertsort Size：10 Range：0~10 2222223 623112 Size：20 Range：0~20 1433779 487111 Size：30 Range：0~30 3454668 540889 单位：nanosecond环境：CPU 4核8线程 2.30GHZ 2.检查范围，以及终止条件// 检查下标是否越界 super.rangeCheck(sequ.length, left, right); // 数组个数为0或1，已排序（终止条件） int size = right - left + 1; if (size &lt; 2) { return; } 3.选择基准(pivot)，分割序列3.1 选择基准基准选择常见的有以下三种方法。 序列首/序列尾对于有序序列分割极不平衡 随机选择优于序列首，但开销不小 三数中值分割它将考虑序列中left, right, (left + right) / 2这三个位置的元素值，选择它们的中位数作为基准 进一步，可在三数中值分割的基础上将三个位置上的较小值和较大值分别置于left位置、right位置。在使用下文的分割方式1时可保证两个指针不越过序列端点。 // 三数排序决定基准，left/right/中位 int middle = (left + right) / 2; if (sequ[left].compareTo(sequ[middle]) &gt; 0) { swap(sequ, left, middle); } if (sequ[left].compareTo(sequ[right]) &gt; 0) { swap(sequ, left, right); } if (sequ[middle].compareTo(sequ[right]) &gt; 0) { swap(sequ, middle, right); } // 数组仅有2个或3个元素，此时已经排好序 //（若对小数组使用插入排序，则该语句没有必要） if (!super.insertSortOptimized &amp;&amp; middle == right - 1) { return super.InvalidPoint; } // 将基准（三数中值）放至right-1位置 swap(sequ, middle, right - 1); 3.2 分割策略3.2.1 分割方式1forePoint从前往后找大于pivot的元素，backPoint从后往前找小于pivot的元素，并交换。当forePoint与backPoint相遇后，将pivot放至正确位置。 之后以此类推标红的元素为pivot // 对left+1和right-2之间的范围进行分割 int forePoint = left; int backPoint = right - 1; T pivot = sequ[right - 1]; while (true) { while (sequ[++forePoint].compareTo(pivot) &lt; 0) { } while (sequ[--backPoint].compareTo(pivot) &gt; 0) { } if (forePoint &gt;= backPoint) { // 将基准放到合适位置 swap(sequ, forePoint, right - 1); break; } else { swap(sequ, forePoint, backPoint); } } 相等元素的处理当遇到和基准值相等的值时，应该如何处理？是往左半段移动？还是往右半段移动？特别地，对于forePoint和backPoint同时分别遇到与基准值相等的元素时，应该如何处理？按照[1]中所说，forePoint和backPoint的地位应是等价的，那么它们对于与基准值相等的元素的处理方式也应相同。否则，则会有左半段与右半段不均衡的情况出现，降低快速排序的效率。那么我们还剩下forePoint和backPoint均停止(进行交换)和均不停止(不进行交换)的选择。 [1]中推荐前种做法。那么对于后种做法，可不可行呢？针对上述的三种基准选择方法分别进行分析： 前两种选择的基准均有可能是该序列中的最大值或者最小值，序列中可能存在其他与该值相同的元素，也可能不存在。因此，必须考虑forePoint和backPoint越过序列端点的情况，停止与不停止并没有差别。 而对于三数中值分割，它所选择的基准，最大仅可能是该序列中的次大值（可能等于最大值），或者最小仅可能是次小值（可能等于最小值）。若在三数中值分割的基础上将三个位置上的较小值和较大值分别置于left位置、right位置，那么，forePoint和backPoint则无法越过序列端点。但考虑到right位置与基准值相等的情况，若采用不停止的方式，则需要再次考虑forePoint越过序列端点的情况，因此，遇到与基准相等的元素，forePoint或者backPoint停止并且交换的做法相对更佳。其实值等于pivot的元素在该次快速排序中，既可以随便出现在左半段，也可以随便出现在右半段，不用恰好紧挨在该次被作为pivot的元素周围。因为，随着之后对于左半段和右半段调用的快速排序，它们会各自被放到正确的位置上，这并不属于该次快速排序的职责。 3.2.2 分割方式2curPoint从前往后遍历序列，parPoint指向小于基准与大于等于基准的序列的分割位置 —— 大于等于基准的序列的第一个元素。当curPoint遍历结束，将pivot与parPoint位置的元素交换。 之后以此类推标红的元素为pivot // 对left+1和right-2之间的范围进行分割 int curPoint = left + 1; int parPoint = left + 1; T pivot = sequ[right - 1]; while(curPoint &lt; right - 1) { if(sequ[curPoint].compareTo(pivot) &lt; 0) { swap(sequ, curPoint, parPoint); parPoint++; } curPoint++; } swap(sequ, parPoint, right - 1); 4. 对pivot的左半段和右半段序列分别进行快速排序4.1 递归int partionPoint = partition(sequ, left, right); if(partionPoint &lt; 0) { return; } executeProcess(sequ, left, partionPoint - 1); executeProcess(sequ, partionPoint + 1, right); 4.2 非递归采用栈保存下次要进行分割的序列首尾位置，深度优先。 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int partionPoint = partition(sequ, left, right); if(partionPoint &lt; 0) { return; } stack.push(partionPoint + 1); stack.push(right); stack.push(left); stack.push(partionPoint - 1); while(!stack.isEmpty()) { int sRight = stack.pop(); int sLeft = stack.pop(); partionPoint = partition(sequ, sLeft, sRight); if(partionPoint &lt; 0) { continue; } stack.push(partionPoint + 1); stack.push(sRight); stack.push(sLeft); stack.push(partionPoint - 1); } About Error 若产生无限循环，则问题可能出在两个方面：一个是递归终止条件；另一个是分割序列处的循环，尤其注意forePoint和backPoint同时分别遇到与基准值相等的元素时，forePoint和backPoint的移动情况 若没有正确排序，由于结果基本有序，我们可以从错误序列中看出端倪。如以下情况： Before: 8 3 15 13 2 0 0 5 10 2 1 9 7 3 9 10 15 5 8 2 9 12 1 8 10 After: 0 0 1 1 2 2 2 3 3 5 5 7 8 8 9 8 9 9 10 10 10 12 13 15 15 共有25个元素，下标14和15位置的元素没有正确排序。25的分割沿着出错位置依次为0~11 12 13~24； 13~17 18 19~24; 13~14 15 16~17。 即可知道是13~17这次快速排序发生差错，从而进行仔细调试。 More[3] 中通过尾递归对快速排序C语言版优化。关于尾递归，[4]讲述得比较明了。然而Java没有实现尾递归优化。相对的，我们只能采取避免递归过深或者用迭代取代递归的方式。 It’s important to note that this isn’t a bug in the JVM. It’s an optimization that can be implemented to help functional programmers who use recursion, which is much more common and normal in those languages. I recently spoke to Brian Goetz at Oracle about this optimization, and he said that it’s on a list of things to be added to the JVM, but it’s just not a high-priority item. For now, it’s best to make this optimization yourself, if you can, by avoiding deeply recursive functions when coding a functional language on the JVM. 性能比较 基准选择 分割策略 递归？ 插排优化？ ver1 三数中值分割 分割方式1 递归 否 ver2 三数中值分割 分割方式2 递归 否 ver3 三数中值分割 分割方式1 非递归 否 ver1 ver2 ver3 Round1 8283115 11229782 2312889 Round2 2574668 4175557 2521779 Round3 2995112 2246667 3599113 单位：nanosecond环境：CPU 4核8线程 2.30GHZ测试序列：长度100范围0~100的随机数序列 代码地址 参考文献1 Mark Allen Weiss[美]. 数据结构与算法分析: Java语言描述:第2版[M]. 机械工业出版社, 2012.2 ThomasH.Cormen…. 算法导论:第2版[M]. 机械工业出版社, 2007.3 http://blog.csdn.net/insistgogo/article/details/77850384 http://www.ruanyifeng.com/blog/2015/04/tail-call.html","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://site.com/tags/算法与数据结构/"},{"name":"面试","slug":"面试","permalink":"http://site.com/tags/面试/"}],"keywords":[]},{"title":"Android Studio - gradle配置踩坑","slug":"Android-Gradle-Settings","date":"2016-12-08T15:00:00.000Z","updated":"2016-12-09T14:10:09.616Z","comments":true,"path":"2016/12/08/Android-Gradle-Settings/","link":"","permalink":"http://site.com/2016/12/08/Android-Gradle-Settings/","excerpt":"","text":"1.问题当我们从团队协作者或者开源Android项目网站上获取以Gradle构建的Android项目，并点击Open an existing Android Studio project将它导入Android Studio时，经常遇到如下Android Studio未响应的问题： 2.分析查看idea.log，我们得知问题是由Started sync with Gradle时造成Connection Failed而引发的。 原因之一可能是该Android项目所需的Gradle版本与本地存在的Gradle版本并不适配。因此，Android Studio会自动去下载该Android项目所需的Gradle版本。 然而，却跪倒在GFW面前。 3.解决通过在Android Studio中依次点击File &gt; Settings &gt; Build, Execution, Deployment &gt; Gradle,我们可以锁定当前项目使用的Gradle的位置。[2] - 若选中`Use default gradle wrapper(recommended)`,则设置的Gradle位置为`Service directory path`中的路径； - 若选中`Use local gradle distribution`，则设置的Gradle位置为`Gradle home`中的路径。 注：Service directory path是全局级的，Use default gradle wrapper(recommended)与Use local gradle distribution是项目级的，优先级高于全局级的设置。 因此，根据当前设置，我们在C:\\Users\\%Your_User_Name%\\.gradle\\wrapper\\dists目录下找到当前已安装的Gradle，并确保Gradle的完整性。 下图是Android Studio Gradle插件版本与Gradle版本之间的对应关系[1]。 Gradle插件版本一般继承自Android Studio的版本。 博主的本地环境为 plugin version required gradle version 2.2.2 2.14.1 因此，对该Android项目的build.gradle和gradle\\wrapper\\gradle-wrapper.properties这两个文件进行修改[1]。 修改过后，可对该Android项目进行正常导入，并且不会出现上述的未响应情况。 参考文献：1 Android Plugin for Gradle Release Notes2 Configure Gradle project settings","categories":[],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://site.com/tags/Android-Studio/"},{"name":"配置","slug":"配置","permalink":"http://site.com/tags/配置/"}],"keywords":[]},{"title":"君名","slug":"your-name","date":"2016-12-06T02:00:00.000Z","updated":"2016-12-11T14:35:29.845Z","comments":true,"path":"2016/12/06/your-name/","link":"","permalink":"http://site.com/2016/12/06/your-name/","excerpt":"","text":"与秒五不同，诚哥这次居然大发善心，给了个Happy End。 毕竟是讲少男少女邂逅之前的故事。不过那个邂逅语真的好吗？我好像在哪里见过你？所有的一见钟情都是前世修福？ 然而我的心中依旧忧伤淡淡，我想，我伤悲的应该是他们失去，忘了曾经快乐的经历，从零开始？而这段交换身体的经历，构成本影的最大笑点，似乎永远都只能在海量神经元中零散地苟活。 我害怕忘记，害怕忘记当时的感觉。如果忘了，那么当时的那种感觉又算什么？是矫情？是廉价的掩饰？所幸这段经历总在男女主的某个地方留下痕迹。 缠结…是产灵，是时间…我想，这就是本影所基于的神秘力量。若按照时间线观点，则会遇到“蛋生鸡、鸡生蛋”的逻辑闭环，也与“改变历史必然产生重大影响”的未经验证的普遍认识不符。与深入人心的时间线观不同，丝带的缠结，让本影的男女主穿越时间、互换身体。回顾下丝带接力（以泷的时间观），三年前的三叶将丝带传给三年前的泷；互换身体的故事；泷将丝带还给三年前的三叶；五年后的泷邂逅八年后的三叶…嗯，感觉没什么不可能 其实，有点很佩服男主。不仅是图力，汗珠流得非常青春..啧啧..而且男主不远千里、按图索骥、前来面基，抵御仿佛来自地狱的风雨，终于获得令人艳羡的道具-口嚼酒。换做是我，即使是那样强烈璀璨的情感涌动、遇到那么色彩斑斓的记忆，应该还是不足以支撑我的行动… 不过，本影刻画男女主互相爱慕的产生过程有些欠缺，虽然后面的相互追逐、爱的表达十分满分。不是青梅竹马，胜似青梅竹马？本影略去了三叶说服dad,男版三叶的第一天表现。前者没有必要表现，但后者真的相当令人期待！我对本影还存在以下疑问：开场应该是男版三叶(卧室)和正常三叶(饭桌)的切换，不过为什么会是无缝链接？教授课程的老师CV大概是香菜？三叶向往的是下辈子成为东京的大帅哥，那么泷向往的是…(@四叶：完了完了) 彗星红、星空蓝、碧海青…这些颜色的组合、交融，真的很美、很艺术。尤其在电影院的大屏幕上显现，带来的视觉震撼难以形容。秉持一贯的文化承载，这次的圣地巡礼是在岐阜县飞弹市，神社、天桥(未果通话)、朱红栏杆(初次邂逅)…什么时候国漫也能够对一些古都/或者日常进行取景，让我们也能快快乐乐地巡礼，就好了！ 总结：首尾呼应、中间欢快、末尾感动。我的表情：[疑问][微笑][大笑][可爱][撇嘴][擦汗][爱心][呲牙][吓][强] 谨以此记君名的一周目。君名告诉我们，写在手上(@泷的手)，写在电子设备上(@泷的手机)，都是没有用的，都会消失不见踪影，只有好好地把它们写在纸上(@泷敲棒的画)，才会在时间的洪流面前面不改色。嗯，仅有纸，才是记住你的名字的最佳方式。 最后，忘了吐槽一句，你们用手机都不看时间的吗？","categories":[],"tags":[{"name":"影评","slug":"影评","permalink":"http://site.com/tags/影评/"}],"keywords":[]}]}