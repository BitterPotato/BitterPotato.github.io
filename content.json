{"meta":{"title":"Yang Weijie's blog","subtitle":"Welcome and have fun!","description":"这个人懒死了，什么都没有写('・ˍ・ `)","author":"Yang Weijie","url":"http://site.com"},"pages":[],"posts":[{"title":"三月的狮子","slug":"三月的狮子","date":"2017-04-29T10:40:00.000Z","updated":"2017-04-29T10:43:06.297Z","comments":true,"path":"2017/04/29/三月的狮子/","link":"","permalink":"http://site.com/2017/04/29/三月的狮子/","excerpt":"","text":"“哈？你现在又要去破坏那个家庭了吗？真可怜~”香子这样说。 一直在想，零恍若溺亡的悲剧感为何被塑造得如此成功，如此具有代入感？每次零得到救赎的时候，总感觉，自己…自己，内心仿佛被几缕阳光照射到，是那样地温暖，可却那样地短暂。 零面前有三座大山，最大的一座来自家庭，而另外两座则由家庭派生而来，一是职业，二是交际。 诚如零自身所言，他的到来，摧毁了幸田家的两只雏鸟，占据了养父所有关于将棋的视线。零的父母、妹妹死于车祸，第一个家庭是零的痛苦；养父是真正关心零的，香子与弟弟和零相爱相杀（雾），第二个家庭是零的现实；明里姐、日向、桃子的体贴、元气、可爱，第三个家庭是零的救赎。好比拾级于天国的阶梯，生活总会慢慢好起来的，不是吗？ 零不是真正热爱将棋，他只是有不得不这么做的理由：生存。 将棋，总有赢的一方，总有输的一方。表面上看，赢的人剥夺了输的人快乐乃至幸福的权利。难道为了自己的生存，就要剥夺其他人的快乐吗？这是零作为一个温柔的人，曾经想到的！但是，输的人，之所以输，不就是因为他们弱吗？只有这次输了，他们才想要变强。难道这次输了，以后就再也不下将棋了，就这样逃避了吗？难道没有眼睁睁看到输的结果，就要轻言放弃了吗？棋局虽小，但变化无穷，将棋本身与下将棋的人，能够让我们看到，看到那么多思考，甚至发现新的一个自己。事情怎么会轻松地按照你所想的那样去发展呢，谁都会被现实当头棒喝，无论是零输给岛田，还是岛田四连败给宗谷。运动员在没有比赛的时候会做什么？我们能够做的，只有不断练习，练习，练习啊！ 零的身旁一直没有人，面对早已形成的小的交际圈子毫无融入之力。中饭偷偷在天台孤单地吃，郊游活动一个人偷偷躲起来吃饭，公寓也没能好好照顾自己（空荡的冰箱、房间；许久之后才购置的窗帘足以说明一切）。不要脸地说，我的身上有他的影子。其实，很多人身上都有他的影子。百感交集，还能怎么办呢。对自己的现状深以为然，但却无力改变、无心改变，就这样溺亡在碧蓝的水中，透不过气来，沉下去… 零是那么温柔，好好地、考虑周全地照顾岛田，甚至有一种啰嗦的感觉。突然好想给冷漠的自己抽好几个耳刮子。 零是那么强，正如班主任所说，作为一名高中生，既要照顾自己，又要准备将棋，还要应付高中教育。这是我处于与零同龄的时候不敢想象的。我认为，这对于零而言，不仅是一份剥夺，也是上帝的一份恩赐。正常人痴睡傻玩的高中是一种高中，零恢弘色彩的高中也是一种高中。谁又能说谁的一定更好呢？唯个人喜好耳。 感慨止于此XD","categories":[],"tags":[{"name":"影评","slug":"影评","permalink":"http://site.com/tags/影评/"}],"keywords":[]},{"title":"QuickSort","slug":"QuickSort","date":"2016-12-13T04:05:57.000Z","updated":"2017-03-19T15:01:17.105Z","comments":true,"path":"2016/12/13/QuickSort/","link":"","permalink":"http://site.com/2016/12/13/QuickSort/","excerpt":"","text":"概述快速排序是面试中的常见题，每次简述一遍快速排序的原理便觉得仿佛已经掌握了它。不是挺简单的吗？然而实际实现的时候还是会遇到一些坑。于是，之前一次面试就跪了，很尴尬。所以，还是需要对它进行深入理解！ 基本步骤 检查范围，(以及终止条件) 注意递归终止条件 选择基准(pivot)，分割序列 即筛选不大于pivot的元素和不小于pivot的元素），将pivot放至正确位置 对pivot的左半段和右半段序列分别进行快速排序 参考[1], 我将快速排序的函数签名定为public &lt;T extends Comparable&lt;? super T&gt;&gt; void executeProcess(T[] sequ, int left, int right) { } 1.小数组优化递归的快速排序终会落入对于小数组的排序。而对于小数组的排序，快速排序不如插入排序。 quicksort insertsort Size：10 Range：0~10 2222223 623112 Size：20 Range：0~20 1433779 487111 Size：30 Range：0~30 3454668 540889 单位：nanosecond环境：CPU 4核8线程 2.30GHZ 2.检查范围，以及终止条件// 检查下标是否越界 super.rangeCheck(sequ.length, left, right); // 数组个数为0或1，已排序（终止条件） int size = right - left + 1; if (size &lt; 2) { return; } 3.选择基准(pivot)，分割序列3.1 选择基准基准选择常见的有以下三种方法。 序列首/序列尾对于有序序列分割极不平衡 随机选择优于序列首，但开销不小 三数中值分割它将考虑序列中left, right, (left + right) / 2这三个位置的元素值，选择它们的中位数作为基准 进一步，可在三数中值分割的基础上将三个位置上的较小值和较大值分别置于left位置、right位置。在使用下文的分割方式1时可保证两个指针不越过序列端点。 // 三数排序决定基准，left/right/中位 int middle = (left + right) / 2; if (sequ[left].compareTo(sequ[middle]) &gt; 0) { swap(sequ, left, middle); } if (sequ[left].compareTo(sequ[right]) &gt; 0) { swap(sequ, left, right); } if (sequ[middle].compareTo(sequ[right]) &gt; 0) { swap(sequ, middle, right); } // 数组仅有2个或3个元素，此时已经排好序 //（若对小数组使用插入排序，则该语句没有必要） if (!super.insertSortOptimized &amp;&amp; middle == right - 1) { return super.InvalidPoint; } // 将基准（三数中值）放至right-1位置 swap(sequ, middle, right - 1); 3.2 分割策略3.2.1 分割方式1forePoint从前往后找大于pivot的元素，backPoint从后往前找小于pivot的元素，并交换。当forePoint与backPoint相遇后，将pivot放至正确位置。 之后以此类推标红的元素为pivot // 对left+1和right-2之间的范围进行分割 int forePoint = left; int backPoint = right - 1; T pivot = sequ[right - 1]; while (true) { while (sequ[++forePoint].compareTo(pivot) &lt; 0) { } while (sequ[--backPoint].compareTo(pivot) &gt; 0) { } if (forePoint &gt;= backPoint) { // 将基准放到合适位置 swap(sequ, forePoint, right - 1); break; } else { swap(sequ, forePoint, backPoint); } } 相等元素的处理当遇到和基准值相等的值时，应该如何处理？是往左半段移动？还是往右半段移动？特别地，对于forePoint和backPoint同时分别遇到与基准值相等的元素时，应该如何处理？按照[1]中所说，forePoint和backPoint的地位应是等价的，那么它们对于与基准值相等的元素的处理方式也应相同。否则，则会有左半段与右半段不均衡的情况出现，降低快速排序的效率。那么我们还剩下forePoint和backPoint均停止(进行交换)和均不停止(不进行交换)的选择。 [1]中推荐前种做法。那么对于后种做法，可不可行呢？针对上述的三种基准选择方法分别进行分析： 前两种选择的基准均有可能是该序列中的最大值或者最小值，序列中可能存在其他与该值相同的元素，也可能不存在。因此，必须考虑forePoint和backPoint越过序列端点的情况，停止与不停止并没有差别。 而对于三数中值分割，它所选择的基准，最大仅可能是该序列中的次大值（可能等于最大值），或者最小仅可能是次小值（可能等于最小值）。若在三数中值分割的基础上将三个位置上的较小值和较大值分别置于left位置、right位置，那么，forePoint和backPoint则无法越过序列端点。但考虑到right位置与基准值相等的情况，若采用不停止的方式，则需要再次考虑forePoint越过序列端点的情况，因此，遇到与基准相等的元素，forePoint或者backPoint停止并且交换的做法相对更佳。其实值等于pivot的元素在该次快速排序中，既可以随便出现在左半段，也可以随便出现在右半段，不用恰好紧挨在该次被作为pivot的元素周围。因为，随着之后对于左半段和右半段调用的快速排序，它们会各自被放到正确的位置上，这并不属于该次快速排序的职责。 3.2.2 分割方式2curPoint从前往后遍历序列，parPoint指向小于基准与大于等于基准的序列的分割位置 —— 大于等于基准的序列的第一个元素。当curPoint遍历结束，将pivot与parPoint位置的元素交换。 之后以此类推标红的元素为pivot // 对left+1和right-2之间的范围进行分割 int curPoint = left + 1; int parPoint = left + 1; T pivot = sequ[right - 1]; while(curPoint &lt; right - 1) { if(sequ[curPoint].compareTo(pivot) &lt; 0) { swap(sequ, curPoint, parPoint); parPoint++; } curPoint++; } swap(sequ, parPoint, right - 1); 4. 对pivot的左半段和右半段序列分别进行快速排序4.1 递归int partionPoint = partition(sequ, left, right); if(partionPoint &lt; 0) { return; } executeProcess(sequ, left, partionPoint - 1); executeProcess(sequ, partionPoint + 1, right); 4.2 非递归采用栈保存下次要进行分割的序列首尾位置，深度优先。 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int partionPoint = partition(sequ, left, right); if(partionPoint &lt; 0) { return; } stack.push(partionPoint + 1); stack.push(right); stack.push(left); stack.push(partionPoint - 1); while(!stack.isEmpty()) { int sRight = stack.pop(); int sLeft = stack.pop(); partionPoint = partition(sequ, sLeft, sRight); if(partionPoint &lt; 0) { continue; } stack.push(partionPoint + 1); stack.push(sRight); stack.push(sLeft); stack.push(partionPoint - 1); } About Error 若产生无限循环，则问题可能出在两个方面：一个是递归终止条件；另一个是分割序列处的循环，尤其注意forePoint和backPoint同时分别遇到与基准值相等的元素时，forePoint和backPoint的移动情况 若没有正确排序，由于结果基本有序，我们可以从错误序列中看出端倪。如以下情况： Before: 8 3 15 13 2 0 0 5 10 2 1 9 7 3 9 10 15 5 8 2 9 12 1 8 10 After: 0 0 1 1 2 2 2 3 3 5 5 7 8 8 9 8 9 9 10 10 10 12 13 15 15 共有25个元素，下标14和15位置的元素没有正确排序。25的分割沿着出错位置依次为0~11 12 13~24； 13~17 18 19~24; 13~14 15 16~17。 即可知道是13~17这次快速排序发生差错，从而进行仔细调试。 More[3] 中通过尾递归对快速排序C语言版优化。关于尾递归，[4]讲述得比较明了。然而Java没有实现尾递归优化。相对的，我们只能采取避免递归过深或者用迭代取代递归的方式。 It’s important to note that this isn’t a bug in the JVM. It’s an optimization that can be implemented to help functional programmers who use recursion, which is much more common and normal in those languages. I recently spoke to Brian Goetz at Oracle about this optimization, and he said that it’s on a list of things to be added to the JVM, but it’s just not a high-priority item. For now, it’s best to make this optimization yourself, if you can, by avoiding deeply recursive functions when coding a functional language on the JVM. DualPivotQuicksortJava中对于基本数据类型的排序算法通过DualPivotQuicksort实现。它有如下特性：This algorithm offers O(n log(n)) performance on many data sets that cause other quicksorts to degrade to quadratic performance, and is typically faster than traditional (one-pivot) Quicksort implementations. 排序方式具体如下： For small arrays (length &lt; 17), use the Insertion sort algorithm. Choose two pivot elements P1 and P2. We can get, for example, the first element a[left] as P1 and the last element a[right] as P2. P1 must be less than P2, otherwise they are swapped. So, there are the following parts: part I with indices from left+1 to L–1 with elements, which are less than P1, part II with indices from L to K–1 with elements, which are greater or equal to P1 and less or equal to P2, part III with indices from G+1 to right–1 with elements greater than P2, part IV contains the rest of the elements to be examined with indices from K to G. The next element a[K] from the part IV is compared with two pivots P1 and P2, and placed to the corresponding part I, II, or III. The pointers L, K, and G are changed in the corresponding directions. The steps 4 - 5 are repeated while K ≤ G. The pivot element P1 is swapped with the last element from part I, the pivot element P2 is swapped with the first element from part III. The steps 1 - 7 are repeated recursively for every part I, part II, and part III. 性能比较 基准选择 分割策略 递归？ 插排优化？ ver1 三数中值分割 分割方式1 递归 否 ver2 三数中值分割 分割方式2 递归 否 ver3 三数中值分割 分割方式1 非递归 否 ver1 ver2 ver3 Round1 8283115 11229782 2312889 Round2 2574668 4175557 2521779 Round3 2995112 2246667 3599113 单位：nanosecond环境：CPU 4核8线程 2.30GHZ测试序列：长度100范围0~100的随机数序列 代码地址 参考文献1 Mark Allen Weiss[美]. 数据结构与算法分析: Java语言描述:第2版[M]. 机械工业出版社, 2012.2 ThomasH.Cormen…. 算法导论:第2版[M]. 机械工业出版社, 2007.3 http://blog.csdn.net/insistgogo/article/details/77850384 http://www.ruanyifeng.com/blog/2015/04/tail-call.html5 http://stackoverflow.com/questions/20917617/whats-the-difference-of-dual-pivot-quick-sort-and-quick-sort","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://site.com/tags/算法与数据结构/"},{"name":"面试","slug":"面试","permalink":"http://site.com/tags/面试/"}],"keywords":[]},{"title":"Android Studio - gradle配置踩坑","slug":"Android-Gradle-Settings","date":"2016-12-08T15:00:00.000Z","updated":"2016-12-09T14:10:09.616Z","comments":true,"path":"2016/12/08/Android-Gradle-Settings/","link":"","permalink":"http://site.com/2016/12/08/Android-Gradle-Settings/","excerpt":"","text":"1.问题当我们从团队协作者或者开源Android项目网站上获取以Gradle构建的Android项目，并点击Open an existing Android Studio project将它导入Android Studio时，经常遇到如下Android Studio未响应的问题： 2.分析查看idea.log，我们得知问题是由Started sync with Gradle时造成Connection Failed而引发的。 原因之一可能是该Android项目所需的Gradle版本与本地存在的Gradle版本并不适配。因此，Android Studio会自动去下载该Android项目所需的Gradle版本。 然而，却跪倒在GFW面前。 3.解决通过在Android Studio中依次点击File &gt; Settings &gt; Build, Execution, Deployment &gt; Gradle,我们可以锁定当前项目使用的Gradle的位置。[2] - 若选中`Use default gradle wrapper(recommended)`,则设置的Gradle位置为`Service directory path`中的路径； - 若选中`Use local gradle distribution`，则设置的Gradle位置为`Gradle home`中的路径。 注：Service directory path是全局级的，Use default gradle wrapper(recommended)与Use local gradle distribution是项目级的，优先级高于全局级的设置。 因此，根据当前设置，我们在C:\\Users\\%Your_User_Name%\\.gradle\\wrapper\\dists目录下找到当前已安装的Gradle，并确保Gradle的完整性。 下图是Android Studio Gradle插件版本与Gradle版本之间的对应关系[1]。 Gradle插件版本一般继承自Android Studio的版本。 博主的本地环境为 plugin version required gradle version 2.2.2 2.14.1 因此，对该Android项目的build.gradle和gradle\\wrapper\\gradle-wrapper.properties这两个文件进行修改[1]。 修改过后，可对该Android项目进行正常导入，并且不会出现上述的未响应情况。 参考文献：1 Android Plugin for Gradle Release Notes2 Configure Gradle project settings","categories":[],"tags":[{"name":"Android Studio","slug":"Android-Studio","permalink":"http://site.com/tags/Android-Studio/"},{"name":"配置","slug":"配置","permalink":"http://site.com/tags/配置/"}],"keywords":[]},{"title":"君名","slug":"your-name","date":"2016-12-06T02:00:00.000Z","updated":"2017-03-19T14:59:58.517Z","comments":true,"path":"2016/12/06/your-name/","link":"","permalink":"http://site.com/2016/12/06/your-name/","excerpt":"","text":"与秒五不同，诚哥这次居然大发善心，给了个Happy End。 毕竟是讲少男少女邂逅之前的故事。不过那个邂逅语真的好吗？我好像在哪里见过你？所有的一见钟情都是前世修福？ 然而我的心中依旧忧伤淡淡，我想，我伤悲的应该是他们失去，忘了曾经快乐的经历，从零开始？而这段交换身体的经历，构成本影的最大笑点，似乎永远都只能在海量神经元中零散地苟活。 我害怕忘记，害怕忘记当时的感觉。如果忘了，那么当时的那种感觉又算什么？是矫情？是廉价的掩饰？所幸这段经历总在男女主的某个地方留下痕迹。 缠结…是产灵，是时间…我想，这就是本影所基于的神秘力量。若按照时间线观点，则会遇到“蛋生鸡、鸡生蛋”的逻辑闭环，也与“改变历史必然产生重大影响”的未经验证的普遍认识不符。与深入人心的时间线观不同，丝带的缠结，让本影的男女主穿越时间、互换身体。回顾下丝带接力（以泷的时间观），三年前的三叶将丝带传给三年前的泷；互换身体的故事；泷将丝带还给三年前的三叶；五年后的泷邂逅八年后的三叶…嗯，感觉没什么不可能 其实，有点很佩服男主。不仅是图力，汗珠流得非常青春..啧啧..而且男主不远千里、按图索骥、前来面基，抵御仿佛来自地狱的风雨，终于获得令人艳羡的道具-口嚼酒。换做是我，即使是那样强烈璀璨的情感涌动、遇到那么色彩斑斓的记忆，应该还是不足以支撑我的行动… 不过，本影刻画男女主互相爱慕的产生过程有些欠缺，虽然后面的相互追逐、爱的表达十分满分。不是青梅竹马，胜似青梅竹马？本影略去了三叶说服dad,男版三叶的第一天表现。前者没有必要表现，但后者真的相当令人期待！我对本影还存在以下疑问：开场应该是男版三叶(卧室)和正常三叶(饭桌)的切换，不过为什么会是无缝链接？三叶向往的是下辈子成为东京的大帅哥，那么泷向往的是…(@四叶：完了完了) 彗星红、星空蓝、碧海青…这些颜色的组合、交融，真的很美、很艺术。尤其在电影院的大屏幕上显现，带来的视觉震撼难以形容。秉持一贯的文化承载，这次的圣地巡礼是在岐阜县飞弹市，神社、天桥(未果通话)、朱红栏杆(初次邂逅)…什么时候国漫也能够对一些古都/或者日常进行取景，让我们也能快快乐乐地巡礼，就好了！ 总结：首尾呼应、中间欢快、末尾感动。我的表情：[疑问][微笑][大笑][可爱][撇嘴][擦汗][爱心][呲牙][吓][强] 谨以此记君名的一周目。君名告诉我们，写在手上(@泷的手)，写在电子设备上(@泷的手机)，都是没有用的，都会消失不见踪影，只有好好地把它们写在纸上(@泷敲棒的画)，才会在时间的洪流面前面不改色。嗯，仅有纸，才是记住你的名字的最佳方式。 最后，忘了吐槽一句，你们用手机都不看时间的吗？","categories":[],"tags":[{"name":"影评","slug":"影评","permalink":"http://site.com/tags/影评/"}],"keywords":[]}]}